declare -a sub_to=("abstract type AbstractField end"
    "abstract type Discrete<:AbstractField end"
    "abstract type Continuous<:AbstractField end"
    "abstract type Constant<:AbstractField end"
    "abstract type Variable<:AbstractField end"
    "abstract type TimeVariant<:AbstractField end"
    "abstract type TimeInvariant<:AbstractField end"
    "const FieldSet = Dict{String,Field}"
    "const DCTI = Field{Discrete,Constant,TimeInvariant}"
    "const DVTI = Field{Discrete,Variable,TimeInvariant}"
    "const DCTV = Field{Discrete,Constant,TimeVariant}"
    "const DVTV = Field{Discrete,Variable,TimeVariant}"
    "const CCTI = Field{Continuous,Constant,TimeInvariant}"
    "const CVTI = Field{Continuous,Variable,TimeInvariant}"
    "const CCTV = Field{Continuous,Constant,TimeVariant}"
    "const CVTV = Field{Continuous,Variable,TimeVariant}"
    "const Node = Vector{Float64}"
    "abstract type AbstractPoint end"
    "const IP = Point{IntegrationPoint}"
    "abstract type AbstractElement end"
    "const CartesianLineElement = Union{Seg2,Seg3,NSeg}"
    "const CartesianSurfaceElement = Union{Quad4,Quad8,Quad9,NSurf}"
    "const CartesianVolumeElement = Union{Hex8,Hex20,Hex27,NSolid}"
    "const TriangularElement = Union{Tri3,Tri6,Tri7}"
    "const TetrahedralElement = Union{Tet4,Tet10}"
    "const PrismaticElement = Union{Wedge6,Wedge15}"
    "const LinearElement = Union{Seg2,Tri3,Quad4,Tet4,Wedge6,Hex8}"
    "const QuadraticElement = Union{Seg3,Tri6,Tri7,Tet10,Quad8,Quad9,Wedge15,Hex20,Hex27}"
    "const SparseVectorCOO = SparseMatrixCOO"
    "abstract type AbstractProblem end"
    "abstract type FieldProblem<:AbstractProblem end"
    "abstract type BoundaryProblem<:AbstractProblem end"
    "abstract type MixedProblem<:AbstractProblem end"
    "const Elasticity2DSurfaceElements = Union{Poi1,Seg2,Seg3}"
    "const Elasticity2DVolumeElements = Union{Tri3,Tri6,Quad4,Quad8,Quad9}"
    "const Elasticity3DSurfaceElements = Union{Poi1,Tri3,Tri6,Quad4,Quad8,Quad9}"
    "const Elasticity3DVolumeElements = Union{Tet4,Wedge6,Wedge15,Hex8,Tet10,Hex20,Hex27}"
    "const Heat3DVolumeElements = Union{Tet4,Tet10,Hex8,Hex20,Hex27}"
    "const Heat3DSurfaceElements = Union{Tri3,Tri6,Quad4,Quad8,Quad9}"
    "const Heat2DVolumeElements = Union{Tri3,Tri6,Quad4}"
    "const Heat2DSurfaceElements = Union{Seg2,Seg3}"
    "const MortarElements2D = Union{Seg2,Seg3}"
    "const MortarElements3D = Union{Tri3,Tri6,Quad4}"
    "abstract type AbstractSolver end"
    "const ContactElements2D = Union{Seg2}"
    "const ContactElements3D = Union{Tri3,Tri6,Quad4,Quad8,Quad9}"
    "abstract type AbstractMaterial end"
    "abstract type AbstractMaterialProperty end"
    "abstract type AbstractProperty end"
    "abstract type AbstractStep end"
    "abstract type AbstractBoundaryCondition end"
    "abstract type AbstractOutputRequest end"
    "const BOUNDARY_CONDITIONS = Union{BOUNDARY,CLOAD,DLOAD,DSLOAD}"
    "const OUTPUT_REQUESTS = Union{NODE_PRINT,EL_PRINT,SECTION_PRINT}",
    "isassigned"
    "clamp.")


declare -a sub_from=("abstract AbstractField"
    "abstract Discrete <: AbstractField"
    "abstract Continuous <: AbstractField"
    "abstract Constant <: AbstractField"
    "abstract Variable <: AbstractField"
    "abstract TimeVariant <: AbstractField"
    "abstract TimeInvariant <: AbstractField"
    "typealias FieldSet Dict{String, Field}"
    "typealias DCTI Field{Discrete,   Constant, TimeInvariant}"
    "typealias DVTI Field{Discrete,   Variable, TimeInvariant}"
    "typealias DCTV Field{Discrete,   Constant, TimeVariant}"
    "typealias DVTV Field{Discrete,   Variable, TimeVariant}"
    "typealias CCTI Field{Continuous, Constant, TimeInvariant}"
    "typealias CVTI Field{Continuous, Variable, TimeInvariant}"
    "typealias CCTV Field{Continuous, Constant, TimeVariant}"
    "typealias CVTV Field{Continuous, Variable, TimeVariant}"
    "typealias Node Vector{Float64}"
    "abstract AbstractPoint"
    "typealias IP Point{IntegrationPoint}"
    "abstract AbstractElement"
    "typealias CartesianLineElement Union{Seg2, Seg3, NSeg}"
    "typealias CartesianSurfaceElement Union{Quad4, Quad8, Quad9, NSurf}"
    "typealias CartesianVolumeElement Union{Hex8, Hex20, Hex27, NSolid}"
    "typealias TriangularElement Union{Tri3, Tri6, Tri7}"
    "typealias TetrahedralElement Union{Tet4, Tet10}"
    "typealias PrismaticElement Union{Wedge6, Wedge15}"
    "typealias LinearElement Union{Seg2, Tri3, Quad4, Tet4, Wedge6, Hex8}"
    "typealias QuadraticElement Union{Seg3, Tri6, Tri7, Tet10, Quad8, Quad9, Wedge15, Hex20, Hex27}"
    "typealias SparseVectorCOO SparseMatrixCOO"
    "abstract AbstractProblem"
    "abstract FieldProblem <: AbstractProblem"
    "abstract BoundaryProblem <: AbstractProblem"
    "abstract MixedProblem <: AbstractProblem"
    "typealias Elasticity2DSurfaceElements Union{Poi1, Seg2, Seg3}"
    "typealias Elasticity2DVolumeElements Union{Tri3, Tri6, Quad4, Quad8, Quad9}"
    "typealias Elasticity3DSurfaceElements Union{Poi1, Tri3, Tri6, Quad4, Quad8, Quad9}"
    "typealias Elasticity3DVolumeElements Union{Tet4, Wedge6, Wedge15, Hex8, Tet10, Hex20, Hex27}"
    "typealias Heat3DVolumeElements Union{Tet4, Tet10, Hex8, Hex20, Hex27}"
    "typealias Heat3DSurfaceElements Union{Tri3, Tri6, Quad4, Quad8, Quad9}"
    "typealias Heat2DVolumeElements Union{Tri3, Tri6, Quad4}"
    "typealias Heat2DSurfaceElements Union{Seg2, Seg3}"
    "typealias MortarElements2D Union{Seg2, Seg3}"
    "typealias MortarElements3D Union{Tri3, Tri6, Quad4}"
    "abstract AbstractSolver"
    "typealias ContactElements2D Union{Seg2}"
    "typealias ContactElements3D Union{Tri3, Tri6, Quad4, Quad8, Quad9}"
    "abstract AbstractMaterial"
    "abstract AbstractMaterialProperty"
    "abstract AbstractProperty"
    "abstract AbstractStep"
    "abstract AbstractBoundaryCondition"
    "abstract AbstractOutputRequest"
    "typealias BOUNDARY_CONDITIONS Union{BOUNDARY, CLOAD, DLOAD, DSLOAD}"
    "typealias OUTPUT_REQUESTS Union{NODE_PRINT, EL_PRINT, SECTION_PRINT}"
    "isdefined"
    "clamp")

for ((i=0;i<${#sub_from[@]};++i)); do
    str_a="${sub_from[i]}"
    str_b="${sub_to[i]}"
    sed_str="s/${sub_from[i]}/${sub_to[i]}/g"
    # echo "sed ${sed_str} $fl.old > $fl"
    for fl in *.jl; do
        mv $fl $fl.old
        sed "${sed_str}" $fl.old > $fl
        rm -f $fl.old
    done
done
